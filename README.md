[![Go Tests](https://github.com/bitstonks/leftright/actions/workflows/go.yml/badge.svg)](https://github.com/bitstonks/syndi/actions/workflows/go.yml)
[![Go Report Card](https://goreportcard.com/badge/github.com/bitstonks/leftright)](https://goreportcard.com/report/github.com/bitstonks/leftright)
[![Go Reference](https://pkg.go.dev/badge/github.com/bitstonks/leftright.svg)](https://pkg.go.dev/github.com/bitstonks/leftright)
[![Go Version](https://img.shields.io/github/go-mod/go-version/bitstonks/leftright.svg)](https://github.com/bitstonks/leftright/blob/main/go.mod)
[![Module Version](https://img.shields.io/github/v/tag/bitstonks/leftright.svg)](https://github.com/bitstonks/leftright/tags)

# Left Right Concurrency In Go

Left-Right concurrency primitive is a way to achieve arbitrary number wait-free reads from any data structure for the
price of only having a single writer, which is also lock-free, but not wait-free. Waiting time is at most two read
operations. However, writes can be batched, and we only have to pay this waiting cost once we publish the batch.

It does this by keeping two copies of the underlying data structure, one used for reading and one for writing. Whenever
we want (e.g. after every write), we atomically swap them. All readers can immediately start reading from the new side,
while the writer has to wait for outstanding reads to finish before it can write again.

See [example on the lock package][ex-link] for a demo of the lock API.

[ex-link]: https://pkg.go.dev/github.com/bitstonks/leftright/pkg/lock#example-package-Simple

# Specs
* Arbitrary number of concurrent readers.
* Readers are always lock-free and wait-free.
* Single writer (or mutex synchronized).
* Writing is lock-free and wait-free. HOWEVER:
   * There is a wait to publish the written changes to readers.
   * The wait time is at most two reads long.

# Performance
The below data is generated by running `go test -bench=. -benchmem ./pkg/lock/...`. All tests were run on my macbook
and go helpfully displays its specs. 
```
goos: darwin
goarch: amd64
pkg: github.com/bitstonks/leftright/pkg/lock
cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz
```
The tests compare performance of concurrently using a string to string map using
different concurrency primitives. The following were used:
* `LeftRight` - this implementation wrapping two `map[string]string` maps.
* `SyncMap` - used the standard library implementation `sync.Map`.
* `RWLock` - used a single `map[string]string` with an additional `sync.RWLock`.

## Single-threaded read
```
LeftRight_Read              65349165                15.49 ns/op            0 B/op          0 allocs/op
SyncMap_Read                52724152                21.38 ns/op            0 B/op          0 allocs/op
RWLock_Read                 82210857                14.51 ns/op            0 B/op          0 allocs/op
```

## Multi-threaded read (2, 10, 100 readers)
```
LeftRight_Read2             20629242                99.12 ns/op            0 B/op          0 allocs/op
SyncMap_Read2               52196583                21.16 ns/op            0 B/op          0 allocs/op
RWLock_Read2                18427156                59.52 ns/op            0 B/op          0 allocs/op
LeftRight_Read10             3433272               466.3 ns/op             0 B/op          0 allocs/op
SyncMap_Read10              33589022                36.44 ns/op            0 B/op          0 allocs/op
RWLock_Read10                3204243               322.9 ns/op             0 B/op          0 allocs/op
LeftRight_Read100             345256              4371 ns/op               0 B/op          0 allocs/op
SyncMap_Read100              3309114               368.1 ns/op             0 B/op          0 allocs/op
RWLock_Read100                379290              3723 ns/op               0 B/op          0 allocs/op
```

## Write
```
LeftRight_Write              5279343               195.0 ns/op            80 B/op          4 allocs/op
SyncMap_Write               14363601                74.13 ns/op           16 B/op          1 allocs/op
RWLock_Write                37633251                30.42 ns/op            0 B/op          0 allocs/op
```

## Write + read (1, 4 readers)
```
LeftRight_WriteRead1         5761753               193.9 ns/op            80 B/op          4 allocs/op
SyncMap_WriteRead1          17147894                66.24 ns/op           16 B/op          1 allocs/op
RWLock_WriteRead1            2452922               483.9 ns/op             0 B/op          0 allocs/op
LeftRight_WriteRead4         4032364               290.4 ns/op            80 B/op          4 allocs/op
SyncMap_WriteRead4          16403029                68.69 ns/op           16 B/op          1 allocs/op
RWLock_WriteRead4            2306290               489.6 ns/op             0 B/op          0 allocs/op
```

# TODO
* Performance test to compare it with sync.Map.
* A more realistic example with goroutines.
